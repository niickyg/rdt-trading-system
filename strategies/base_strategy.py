"""
Base Strategy Framework

Provides the foundation for implementing multiple trading strategies
that can be combined in a portfolio approach.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, date
from typing import Dict, List, Optional, Any
from enum import Enum
import pandas as pd


class SignalDirection(str, Enum):
    """Direction of trading signal"""
    LONG = "long"
    SHORT = "short"
    FLAT = "flat"


class SignalStrength(str, Enum):
    """Strength/confidence of signal"""
    WEAK = "weak"
    MODERATE = "moderate"
    STRONG = "strong"
    VERY_STRONG = "very_strong"


@dataclass
class StrategySignal:
    """
    Trading signal generated by a strategy

    Contains all information needed to evaluate and execute a trade.
    """
    symbol: str
    direction: SignalDirection
    strength: SignalStrength
    strategy_name: str

    # Entry details
    entry_price: float
    stop_price: float
    target_price: float

    # Sizing info
    atr: float
    risk_per_share: float
    suggested_position_pct: float = 0.01  # Suggested % of capital

    # Metadata
    timestamp: datetime = field(default_factory=datetime.now)
    rrs_value: Optional[float] = None
    additional_data: Dict[str, Any] = field(default_factory=dict)

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate risk/reward ratio"""
        if self.risk_per_share == 0:
            return 0
        reward = abs(self.target_price - self.entry_price)
        return reward / self.risk_per_share

    @property
    def is_valid(self) -> bool:
        """Check if signal has valid parameters"""
        return (
            self.entry_price > 0 and
            self.stop_price > 0 and
            self.target_price > 0 and
            self.risk_reward_ratio >= 1.5
        )

    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            'symbol': self.symbol,
            'direction': self.direction.value,
            'strength': self.strength.value,
            'strategy_name': self.strategy_name,
            'entry_price': self.entry_price,
            'stop_price': self.stop_price,
            'target_price': self.target_price,
            'atr': self.atr,
            'risk_per_share': self.risk_per_share,
            'risk_reward_ratio': self.risk_reward_ratio,
            'suggested_position_pct': self.suggested_position_pct,
            'timestamp': self.timestamp.isoformat(),
            'rrs_value': self.rrs_value,
        }


@dataclass
class StrategyResult:
    """
    Backtest or live trading result for a strategy

    Tracks performance metrics for evaluation and optimization.
    """
    strategy_name: str
    start_date: date
    end_date: date

    # Capital metrics
    initial_capital: float
    final_capital: float

    # Trade metrics
    total_trades: int
    winning_trades: int
    losing_trades: int

    # Return metrics
    total_return: float
    total_return_pct: float
    max_drawdown: float
    max_drawdown_pct: float

    # Risk metrics
    sharpe_ratio: float
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0

    # Efficiency metrics
    win_rate: float
    profit_factor: float
    avg_win: float
    avg_loss: float
    avg_holding_days: float

    # Trade list
    trades: List[Dict] = field(default_factory=list)
    equity_curve: List[Dict] = field(default_factory=list)

    @property
    def expectancy(self) -> float:
        """Calculate expected value per trade"""
        if self.total_trades == 0:
            return 0
        return (self.win_rate * self.avg_win) - ((1 - self.win_rate) * self.avg_loss)

    @property
    def annual_return_pct(self) -> float:
        """Annualize return"""
        days = (self.end_date - self.start_date).days
        if days == 0:
            return 0
        return (self.total_return_pct / days) * 365

    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization"""
        return {
            'strategy_name': self.strategy_name,
            'start_date': str(self.start_date),
            'end_date': str(self.end_date),
            'initial_capital': self.initial_capital,
            'final_capital': self.final_capital,
            'total_return': self.total_return,
            'total_return_pct': self.total_return_pct,
            'annual_return_pct': self.annual_return_pct,
            'total_trades': self.total_trades,
            'win_rate': self.win_rate,
            'profit_factor': self.profit_factor,
            'max_drawdown_pct': self.max_drawdown_pct,
            'sharpe_ratio': self.sharpe_ratio,
            'expectancy': self.expectancy,
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies

    Implement this class to create new strategies that can be
    integrated into the multi-strategy framework.
    """

    def __init__(
        self,
        name: str,
        capital_allocation: float = 0.2,  # 20% of total capital
        max_positions: int = 5,
        risk_per_trade: float = 0.01
    ):
        """
        Initialize strategy

        Args:
            name: Strategy identifier
            capital_allocation: Fraction of total capital allocated
            max_positions: Maximum concurrent positions
            risk_per_trade: Risk per trade as fraction of allocated capital
        """
        self.name = name
        self.capital_allocation = capital_allocation
        self.max_positions = max_positions
        self.risk_per_trade = risk_per_trade

        # State
        self.positions: Dict[str, Dict] = {}
        self.signals: List[StrategySignal] = []
        self.is_active = True

    @abstractmethod
    def scan(
        self,
        stock_data: Dict[str, pd.DataFrame],
        market_data: pd.DataFrame,
        current_date: Optional[date] = None
    ) -> List[StrategySignal]:
        """
        Scan for trading signals

        Args:
            stock_data: Dict mapping symbol to OHLCV DataFrame
            market_data: SPY/market index OHLCV DataFrame
            current_date: Date to scan (for backtesting)

        Returns:
            List of StrategySignal objects
        """
        pass

    @abstractmethod
    def should_exit(
        self,
        symbol: str,
        position: Dict,
        current_data: pd.DataFrame,
        current_date: Optional[date] = None
    ) -> Optional[str]:
        """
        Check if position should be exited

        Args:
            symbol: Stock symbol
            position: Current position info
            current_data: Current OHLCV data
            current_date: Current date

        Returns:
            Exit reason if should exit, None otherwise
        """
        pass

    def calculate_position_size(
        self,
        signal: StrategySignal,
        allocated_capital: float
    ) -> int:
        """
        Calculate position size based on risk parameters

        Args:
            signal: Trading signal
            allocated_capital: Capital allocated to this strategy

        Returns:
            Number of shares to trade
        """
        risk_amount = allocated_capital * self.risk_per_trade
        risk_per_share = abs(signal.entry_price - signal.stop_price)

        if risk_per_share <= 0:
            return 0

        shares = int(risk_amount / risk_per_share)

        # Check max position size (20% of allocated capital)
        max_position_value = allocated_capital * 0.20
        max_shares = int(max_position_value / signal.entry_price)

        return min(shares, max_shares)

    def get_allocation(self, total_capital: float) -> float:
        """Calculate capital allocated to this strategy"""
        return total_capital * self.capital_allocation

    def can_take_new_position(self) -> bool:
        """Check if strategy can take a new position"""
        return len(self.positions) < self.max_positions and self.is_active

    def add_position(self, symbol: str, position_data: Dict):
        """Track a new position"""
        self.positions[symbol] = position_data

    def remove_position(self, symbol: str):
        """Remove a tracked position"""
        if symbol in self.positions:
            del self.positions[symbol]

    def get_metrics(self) -> Dict:
        """Get current strategy metrics"""
        return {
            'name': self.name,
            'allocation': self.capital_allocation,
            'open_positions': len(self.positions),
            'max_positions': self.max_positions,
            'is_active': self.is_active,
            'positions': list(self.positions.keys()),
        }

    def reset(self):
        """Reset strategy state"""
        self.positions = {}
        self.signals = []


class MomentumStrategy(BaseStrategy):
    """
    Example momentum strategy using RRS

    This is the enhanced version of the core RDT strategy
    """

    def __init__(
        self,
        name: str = "RRS_Momentum",
        capital_allocation: float = 0.40,
        max_positions: int = 10,
        risk_per_trade: float = 0.03,
        rrs_threshold: float = 1.75,
        stop_atr_mult: float = 0.75,
        target_atr_mult: float = 1.5
    ):
        super().__init__(name, capital_allocation, max_positions, risk_per_trade)
        self.rrs_threshold = rrs_threshold
        self.stop_atr_mult = stop_atr_mult
        self.target_atr_mult = target_atr_mult

        # Import RRS calculator
        from shared.indicators.rrs import RRSCalculator, check_daily_strength_relaxed
        self.rrs_calc = RRSCalculator()
        self.check_daily = check_daily_strength_relaxed

    def scan(
        self,
        stock_data: Dict[str, pd.DataFrame],
        market_data: pd.DataFrame,
        current_date: Optional[date] = None
    ) -> List[StrategySignal]:
        """Scan for RRS momentum signals"""
        signals = []

        # Get SPY data
        if current_date:
            spy_current = market_data[market_data.index.date <= current_date]
        else:
            spy_current = market_data

        if len(spy_current) < 20:
            return signals

        close_col = 'close' if 'close' in spy_current.columns else 'Close'
        spy_close = spy_current[close_col.lower() if close_col == 'close' else close_col].iloc[-1]
        spy_prev = spy_current[close_col.lower() if close_col == 'close' else close_col].iloc[-2]

        for symbol, data in stock_data.items():
            if symbol in self.positions:
                continue

            try:
                if current_date:
                    current = data[data.index.date <= current_date]
                else:
                    current = data

                if len(current) < 20:
                    continue

                # Normalize columns
                current = current.copy()
                current.columns = [c.lower() for c in current.columns]

                # Calculate indicators
                atr = self.rrs_calc.calculate_atr(current).iloc[-1]
                stock_close = current['close'].iloc[-1]
                stock_prev = current['close'].iloc[-2]

                # Calculate RRS
                rrs_result = self.rrs_calc.calculate_rrs_current(
                    stock_data={'current_price': stock_close, 'previous_close': stock_prev},
                    spy_data={'current_price': spy_close, 'previous_close': spy_prev},
                    stock_atr=atr
                )
                rrs = rrs_result['rrs']

                # Check threshold
                if abs(rrs) < self.rrs_threshold:
                    continue

                # Check daily chart
                daily_check = self.check_daily(current)

                # Generate signal
                if rrs > self.rrs_threshold and daily_check['is_strong']:
                    direction = SignalDirection.LONG
                    stop_price = stock_close - (atr * self.stop_atr_mult)
                    target_price = stock_close + (atr * self.target_atr_mult)
                elif rrs < -self.rrs_threshold:
                    from shared.indicators.rrs import check_daily_weakness_relaxed
                    weak_check = check_daily_weakness_relaxed(current)
                    if weak_check['is_weak']:
                        direction = SignalDirection.SHORT
                        stop_price = stock_close + (atr * self.stop_atr_mult)
                        target_price = stock_close - (atr * self.target_atr_mult)
                    else:
                        continue
                else:
                    continue

                # Determine strength
                if abs(rrs) > 3.0:
                    strength = SignalStrength.VERY_STRONG
                elif abs(rrs) > 2.5:
                    strength = SignalStrength.STRONG
                else:
                    strength = SignalStrength.MODERATE

                signal = StrategySignal(
                    symbol=symbol,
                    direction=direction,
                    strength=strength,
                    strategy_name=self.name,
                    entry_price=stock_close,
                    stop_price=stop_price,
                    target_price=target_price,
                    atr=atr,
                    risk_per_share=abs(stock_close - stop_price),
                    rrs_value=rrs,
                    suggested_position_pct=self.risk_per_trade
                )

                if signal.is_valid:
                    signals.append(signal)

            except Exception:
                continue

        return signals

    def should_exit(
        self,
        symbol: str,
        position: Dict,
        current_data: pd.DataFrame,
        current_date: Optional[date] = None
    ) -> Optional[str]:
        """Check exit conditions"""
        try:
            if current_date:
                data = current_data[current_data.index.date == current_date]
            else:
                data = current_data.tail(1)

            if len(data) == 0:
                return None

            # Normalize columns
            cols = {c.lower(): c for c in data.columns}
            high = data[cols.get('high', 'High')].iloc[0]
            low = data[cols.get('low', 'Low')].iloc[0]
            close = data[cols.get('close', 'Close')].iloc[0]

            direction = position.get('direction', 'long')
            stop_price = position['stop_price']
            target_price = position['target_price']

            if direction == 'long':
                if low <= stop_price:
                    return 'stop_loss'
                if high >= target_price:
                    return 'take_profit'
            else:
                if high >= stop_price:
                    return 'stop_loss'
                if low <= target_price:
                    return 'take_profit'

            # Time-based exit (10 days max)
            entry_date = position.get('entry_date')
            if entry_date and current_date:
                holding_days = (current_date - entry_date).days
                if holding_days >= 10:
                    return 'time_stop'

        except Exception:
            pass

        return None
